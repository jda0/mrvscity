---
title: Logs
author: James Daly
email: j.daly.2015@my.bristol.ac.uk
comments: false
custom_manifest: logs.manifest.json
---

{% assign logs = site.data.logs %}
{% assign meta = site.data.logsmeta %}

{% include template.head.html %}
<section>
  <article>
    <h1>{{ page.title }}</h1>

  {%- for log in logs -%}
  {%- assign log0 = log[0] -%}
  {%- if log0 contains '_' -%}
  {%- else -%}
    <div class="card">
      <h3>{{ log0 }}</h3>
      <div class="data" data-log="{{ log0 }}" data-type="{{ meta[log0].type }}">
    {%- for day in log[1] -%}
    {%- if meta[log0].type == 'boolean' -%}
      <input type="checkbox" title="{{ day[0] }}" id="cb-{{log0}}-{{day[0]}}" {% if day[1] %}checked{% endif %} data-checked={{day[1]}} disabled
      /><label for="cb-{{log0}}-{{day[0]}}" title="{{ day[0] }}"></label>
    {%- elsif meta[log0].type == 'number' -%}
      <input type="number" title="{{ day[0] }}" id="cb-{{log0}}-{{day[0]}}" value="{{day[1]}}" data-value="{{day[1]}}" disabled />
    {%- else -%}
      <input type="text" title="{{ day[0] }}" id="cb-{{log0}}-{{day[0]}}" value="{{day[1]}}" data-value="{{day[1]}}" disabled />
    {%- endif -%}
    {%- endfor -%}
      </div>
    </div>
  {%- endif -%}
  {%- endfor -%}
  </article>
</section>
<section>
  <div id="toolbar"/>
</section>

<script type="text/javascript" src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
<script async type="text/javascript">
  let data = {
  {%- for log in logs -%}
  {%- assign log0 = log[0] -%}
  {%- if log0 contains '_' -%}
  {%- else -%}
    '{{ log[0] }}': {
    {%- for day in log[1] -%}
    {%- if meta[log0].type != 'string' -%}
      '{{ day[0] }}': {{ day[1] }},
    {%- else -%}
      '{{ day[0] }}': '{{ day[1] }}',
    {%- endif -%}
    {%- endfor -%}
    },
  {%- endif -%}
  {%- endfor -%}
  }

  let eque = []
  let savable = {}

  const set = (e) => {
    let log = e.target.parentNode.getAttribute('data-log')
    let item = e.target.getAttribute('title')
    for (let setop in e.set) {
      // if (typeof e.set[setop] === 'boolean') {
        e.target[setop] = e.set[setop]
        if (!e.force && e.set[setop] === e.target.getAttribute(`data-${setop}`)) {
          if (savable[log]) {
            if (savable[log][item]) delete savable[log][item]
            if (!Object.keys(savable[log]).length) delete savable[log]
          }
        } else {
          if (!savable[log]) savable[log] = {}
          savable[log][item] = e.set[setop]
        }
      // } else {
      //   errorStatus('Unknown setop.', true, 'unknown setop', e)
      // }
    }
  }

  const unset = (e) => {
    for (let setop in e.unset) {
      // if (typeof e.unset[setop] === 'boolean') {
        if (e.unset[setop] === null) e.indeterminate = true
        else e.target[setop] = e.unset[setop]
      // } else {
      //   errorStatus('Unknown unsetop.', true, 'unknown unsetop', e)
      // }
    }
  }

  const deque = () => {
    let e = eque.shift()
    let user = netlifyIdentity.currentUser()

    if (user && e.set) {
      set(e)
    } else if (!user && e.unset) {
      unset(e)
    }

    e.target.indeterminate = false
    updateSavable()
  }

  let statusReset
  const status = (message = netlifyIdentity.currentUser().email, opts = {}, ...extendedMessage) => {
    clearTimeout(statusReset)

    if (!opts) opts = {}
    let bc = opts.error ? '#c0392b': '#666'
    let c
    if (opts.group && opts.collapsed) c = 'groupCollapsed'
    else if (opts.group) c = 'group'
    else if (opts.error) c = 'error'
    else c = 'info'
    
    if (message) document.getElementById('status').innerHTML = message
    if (extendedMessage && opts.label) console[c]('%c' + opts.label, `background: ${bc}; color: #fff; font-weight: bolder; padding: 2px 0.5em; border-radius: 0.5em`, ...extendedMessage)
    else if (extendedMessage) console[c](...extendedMessage)

    if (opts.reset !== false && message) statusReset = setTimeout(status, 1500)
  }
  const groupEnd = console.groupEnd

  const clearAndReload = () => {
    caches.keys()
      .then(c => Promise.all(c.map(k => caches.delete(k))))
      .then(location.reload)
  }

  const checkStale = async () => {
    const lastDefined = '{{ logs._commit }}'

    status('Authorising... (1/2)', { reset: false, label: 'checkStale' }, 'Building authorisation headers...')
    const jwt = await netlifyIdentity.currentUser().jwt()
    const headers = {
      Authorization: `Bearer ${jwt}`,
      'Content-Type': 'application/json',
    }

    status('Checking freshness... (2/2)', { reset: false, label: 'checkStale' }, 'Getting ref logs...')
    let res = await fetch('https://mrvs.city/.netlify/git/github/git/refs/heads/logs', { headers })
    const ref = await res.json()

    if (!ref.object || ref.object.type !== 'commit' || !ref.object.sha) throw status('Failed.', { error: true, label: 'checkStale' }, 'Bad ref heads/logs.')

    if (ref.object.sha.slice(0, 7) !== lastDefined) status('Stale! <a href="#" onclick="clearAndReload">Reload</a>', { reset: false, label: 'checkStale' }, `Stale (${ref.object.sha.slice(0, 7)} â‰  ${lastDefined}).`)
    else status('Certified fresh.', { label: 'checkStale' }, 'Up to date.')
  }

  const save = async (data, updates) => {
    let data2 = { ...data }
    for (const key in updates) data2[key] = {
      ...data2[key],
      ...updates[key]
    }

    status('Saving', { group: true, reset: false, label: 'save' }, 'Saving... ', data2)

    status('Authorising... (1/11)', { reset: false, label: 'save' }, 'Building authorisation headers...')
    const jwt = await netlifyIdentity.currentUser().jwt()
    const headers = {
      Authorization: `Bearer ${jwt}`,
      'Content-Type': 'application/json',
    }

    status('Getting master... (2/11)', { reset: false, label: 'save' }, 'Getting ref master...')
    let res = await fetch('https://mrvs.city/.netlify/git/github/git/refs/heads/master', { headers })
    const ref = await res.json()

    if (!ref.object || ref.object.type !== 'commit' || !ref.object.sha) throw errorStatus('Bad master.', false, 'save', 'Bad ref heads/master.')

    const logs_ref = ref.object.sha
    data2._commit = logs_ref.slice(0, 7)
    
    status('Building YAML... (3/11)', { group: true, collapsed: true, reset: false, label: 'save' }, 'Building YAML...')
    let yaml = Object.keys(data2)
      .reduce((a, k) => `${a}\n'${k}': ${
        (typeof data2[k] === 'object')
          ? '\n' +
            Object.keys(data2[k])
              .reduce((a, k2) => `  ${k2}: ${typeof data2[k][k2] === 'string' ? `'${data2[k][k2]}'` : data2[k][k2]}\n${a}`, '')
          : `'${data2[k].toString()}'`
      }`, '')
    status(null, {}, `%c${yaml}`, 'color: #777')
    groupEnd()

    status('Getting HEAD... (4/11)', { reset: false, label: 'save' }, `Getting commit ${ref.object.sha}...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/commits/${ref.object.sha}`, { headers })
    const commit = await res.json()

    if (!commit.tree || !commit.tree.sha) throw errorStatus('Bad commit.', false, 'save', `Bad commit ${ref.object.sha}.`)

    status('Getting tree... (5/11)', { reset: false, label: 'save' }, `Getting tree ${commit.tree.sha} for commit...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/trees/${commit.tree.sha}`, { headers })
    const tree = await res.json()

    if (!tree.tree) throw status('Bad tree.', { error: true, reset: false, label: 'save' }, `Bad tree ${commit.tree.sha}.`)
    const dir = tree.tree.find(e => e.path === '_data' && e.type === 'tree')
    if (!dir) throw status('Bad tree.', { error: true, reset: false, label: 'save' }, `_data/ not found in ${tree.sha}.`)

    status('Getting subtree... (6/11)', { reset: false, label: 'save' }, `Getting subtree ${dir.sha} for _data/...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/trees/${dir.sha}`, { headers })
    const subtree = await res.json()

    if (!subtree.tree) throw status('Bad subtree.', { error: true, reset: false, label: 'save' }, `Bad subtree ${tree.sha}.`)
    const file = subtree.tree.find(e => e.path === 'logs.yaml' && e.type === 'blob')
    if (!file) throw status('Bad subtree.', { error: true, reset: false, label: 'save' }, `logs.yaml not found in ${tree.sha}.`)

    status('Creating blob... (7/11)', { reset: false, label: 'save' }, `Creating new blob for logs...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/blobs`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ content: yaml })
    })
    const new_blob = await res.json()

    if (!new_blob.sha) {
      status('Bad blob.', { groupCollapsed: true, error: true, reset: false, label: 'save' }, `Bad new blob.`)
      status(null, { error: true }, new_blob)
      throw groupEnd()
    }

    const new_subtree_content = {
      base_tree: subtree.sha,
      tree: [
        ...subtree.tree.filter(e => e.path !== 'logs.yaml' || e.type !== 'blob'),
        {
          path: 'logs.yaml',
          mode: '100644',
          type: 'blob',
          sha: new_blob.sha
        }
      ]
    }

    status('Creating subtree... (8/11)', { reset: false, label: 'save' }, `Creating new subtree for _data/ with blob ${new_blob.sha}...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/trees`, {
      method: 'POST',
      headers,
      body: JSON.stringify(new_subtree_content)
    })
    const new_subtree = await res.json()

    if (!new_subtree.sha) {
      status('Bad subtree.', { groupCollapsed: true, error: true, reset: false, label: 'save' }, `Bad new subtree.`)
      status(null, { error: true }, new_subtree)
      throw groupEnd()
    }

    const new_tree_content = {
      base_tree: tree.sha,
      tree: [
        ...tree.tree.filter(e => e.path !== '_data' || e.type !== 'tree'),
        {
          path: '_data',
          mode: '040000',
          type: 'tree',
          sha: new_subtree.sha
        }
      ]
    }

    status('Creating tree... (9/11)', { reset: false, label: 'save' }, `Creating new tree for commit with blob ${new_blob.sha}...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/trees`, {
      method: 'POST',
      headers,
      body: JSON.stringify(new_tree_content)
    })
    const new_tree = await res.json()

    if (!new_tree.sha) {
      status('Bad tree.', { groupCollapsed: true, error: true, reset: false, label: 'save' }, `Bad new tree.`)
      status(null, { error: true }, new_tree)
      throw groupEnd()
    }

    const new_commit_content = {
      message: '* Update logs [auto]',
      tree: new_tree.sha,
      parents: [commit.sha],
      committer: {
        name: 'mrvsbot',
        email: 'bot@mrvs.city',
        date: (new Date()).toISOString()
      }
    }

    status('Creating commit... (10/11)', { reset: false, label: 'save' }, `Creating new commit for tree ${new_tree.sha}...`)
    res = await fetch(`https://mrvs.city/.netlify/git/github/git/commits`, {
      method: 'POST',
      headers,
      body: JSON.stringify(new_commit_content)
    })
    const new_commit = await res.json()

    if (!new_commit.sha) {
      status('Bad commit.', { groupCollapsed: true, error: true, reset: false, label: 'save' }, `Bad new commit.`)
      status(null, { error: true }, new_commit)
      throw groupEnd()
    }

    status('Updating HEAD...', { reset: false, label: 'save' }, `Updating refs for commit ${new_commit.sha}...`)
    fetch(`https://mrvs.city/.netlify/git/github/git/refs/heads/logs`, {
      method: 'PATCH',
      headers,
      body: JSON.stringify({ sha: logs_ref })
    })
      .then(async res => {
        const new_ref = await res.json()
        status(null, { label: 'save' }, `Updated ref heads/logs to ${logs_ref}. `, new_ref)
      })

    res = await fetch(`https://mrvs.city/.netlify/git/github/git/refs/heads/master`, {
      method: 'PATCH',
      headers,
      body: JSON.stringify({ sha: new_commit.sha })
    })
    const new_ref = await res.json()

    groupEnd()
    status('Saved.', { label: 'save' }, 'Done. ', new_ref)

    return data2
  }
  
  const updateSavable = () => {
    let saveEl = document.getElementById('save')

    if (Object.keys(savable).length && saveEl === null) {
      saveEl = document.createElement('input')
      saveEl.setAttribute('id', 'save')
      saveEl.setAttribute('class', 'admin')
      saveEl.setAttribute('type', 'button')
      saveEl.setAttribute('value', 'Save')

      saveEl.addEventListener('click', e => {
        if (!netlifyIdentity.currentUser()) netlifyIdentity.open()
        else {
          document.getElementById('toolbar').removeChild(saveEl)
          save(data, savable)
            .then(data2 => data = data2, savable = {})
            .catch(e => {
              errorStatus('Save failed.', true, e)
              document.getElementById('toolbar').appendChild(saveEl)
            })
        }
      })

      document.getElementById('toolbar').appendChild(saveEl)
    } else if (!Object.keys(savable).length && saveEl !== null) {
      document.getElementById('toolbar').removeChild(saveEl)
    }
  }

  netlifyIdentity.on('login', () => {
    logoutEl = document.createElement('input')
    logoutEl.setAttribute('id', 'logout')
    logoutEl.setAttribute('class', 'admin')
    logoutEl.setAttribute('type', 'button')
    logoutEl.setAttribute('value', `Logout`)

    currentUserEl = document.createElement('span')
    currentUserEl.setAttribute('id', 'status')
    currentUserEl.setAttribute('class', 'admin')
    currentUserEl.innerHTML = netlifyIdentity.currentUser().email

    logoutEl.addEventListener('click', e => {
      document.getElementById('toolbar').removeChild(logoutEl)
      document.getElementById('toolbar').removeChild(currentUserEl)
      netlifyIdentity.logout()
      window.location.reload()
    })

    document.getElementById('toolbar').insertBefore(logoutEl, document.getElementById('save'))
    document.getElementById('toolbar').insertBefore(currentUserEl, logoutEl)
    netlifyIdentity.close()

    checkStale()
  })
  netlifyIdentity.on('close', deque)

  const checkcb = force => e => {
    const attribute = e.target.getAttribute('type') === 'checkbox' ? 'checked' : 'value'
    const value = attribute === 'checked' ? !!e.target[attribute] : e.target[attribute]

    eque.push({
      target: e.target,
      set: { [attribute]: value },
      unset: { [attribute]: e.target.getAttribute(`data-${attribute}`) },
      force: !!force
    })

    e.target.indeterminate = true
    
    if (!netlifyIdentity.currentUser()) netlifyIdentity.open()
    else deque()
  }

  ;(() => {
    const dt = new Date()
    const ds = '' + dt.getUTCFullYear() + ('00' + (dt.getUTCMonth() + 1)).slice(-2) + ('00' + dt.getUTCDate()).slice(-2)

    ;[].forEach.call(document.querySelectorAll('.data'), el => {
      if (!el.querySelector(`input[title="${ds}"]`)) {
        let firstChild = el.firstChild
        let missingEl = document.createElement('input')
        missingEl.setAttribute('type', el.getAttribute('data-type') === 'boolean' ? 'checkbox' : el.getAttribute('data-type'))
        missingEl.setAttribute('id', `cb-${el.getAttribute('data-log')}-${ds}`)
        missingEl.setAttribute('title', ds)
        missingEl.indeterminate = true
        missingEl.addEventListener('change', checkcb(true))
        el.insertBefore(missingEl, firstChild)

        if (el.getAttribute('data-type') === 'boolean') {
          missingEl = document.createElement('label')
          missingEl.setAttribute('for', `cb-${el.getAttribute('data-log')}-${ds}`)
          missingEl.setAttribute('title', ds)
          el.insertBefore(missingEl, firstChild)
        }
      }
    })

    ;[].forEach.call(document.querySelectorAll('.data input'), el => {
      let nextEl = el.nextElementSibling
      if (!nextEl) return
      if (nextEl.tagName !== 'INPUT') nextEl = nextEl.nextElementSibling
      if (!nextEl) return

      let item = el.getAttribute('title')
      let next = nextEl.getAttribute('title')
      item = new Date(item.slice(0, -4), parseInt(item.slice(-4, -2), 10) - 1, item.slice(-2))
      next = new Date(next.slice(0, -4), parseInt(next.slice(-4, -2), 10) - 1, next.slice(-2))

      while (item - next !== 86400000) {
        let missing = new Date(item.valueOf() - 86400000)
        let ms = '' + missing.getUTCFullYear() + ('00' + (missing.getUTCMonth() + 1)).slice(-2) + ('00' + (missing.getUTCDate() + 1)).slice(-2)

        missingEl = document.createElement('input')
        missingEl.setAttribute('type', el.parentNode.getAttribute('data-type') === 'boolean' ? 'checkbox' : el.parentNode.getAttribute('data-type'))
        missingEl.setAttribute('id', `cb-${el.parentNode.getAttribute('data-log')}-${ms}`)
        missingEl.setAttribute('title', ms)
        missingEl.indeterminate = true
        missingEl.addEventListener('change', checkcb(true))
        el.parentNode.insertBefore(missingEl, nextEl)

        if (el.parentNode.getAttribute('data-type') === 'boolean') {
          missingEl = document.createElement('label')
          missingEl.setAttribute('for', `cb-${el.parentNode.getAttribute('data-log')}-${ms}`)
          missingEl.setAttribute('title', ms)
          el.parentNode.insertBefore(missingEl, nextEl)
        }

        item = missing
      }
    })

    ;[].forEach.call(document.querySelectorAll(`.data input[title="${ds}"]:disabled`), el => {
      el.removeAttribute('disabled')
      el.addEventListener('change', checkcb())
    })}
  )()
</script>
{% include template.foot.html %}