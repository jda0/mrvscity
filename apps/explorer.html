---
title: Explorer
author: James Daly
email: j.daly.2015@my.bristol.ac.uk
comments: false
custom_manifest: explorer.manifest.json
---

{% include template.head.html %}
    <style type="text/css">
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        max-width: unset;
        height: 100%;
        transition: 500ms filter ease; 
      }

      canvas.blur {
        filter: blur(0.5rem);
      }

      section {
        position: relative;
        z-index: 1;
      }

      #touchManager {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: 1px solid #000;
      }
    </style>
  </head>
  <body>
      <canvas resize hidpi id="canvas" class="blur"></canvas>
      <section class="intro">
        <h1>Hi. This is explorer.</h1>
        <p>Arrow keys to move, Space or Esc to escape</p>
        <p>Playing without a keyboard? Click on the side of the screen you want to move to, or the bottom-right corner to escape</p>
        <p>Clear all tiles by walking on them</p>
        <ul>
          <li>Red tiles need 1 step</li>
          <li>Orange tiles need 2 steps</li>
          <li>... so on through the rainbow ...</li>
          <li>Black tiles need an undeterminably large number of steps</li>
        </ul>
        <p>To prevent showing this text, add ?hi=false to the url of this page.</p>
        <p>(Click this text to hide it)</p>
      </div>
      <div id="touchManager">&nbsp;</div>
      <script type="text/javascript">
        // Generated by CoffeeScript 1.6.3
        (function() {
          var HUDArray, actionEvent, background, boardSize, cacheBoard, canvas, context, currentPixel, escapeKey, finSym, gameBoard, gameOver, gen, hearts, height, i, keyEvent, keys, lastPixel, level, level2, lives, loadPageVar, numbers, palette, pixelHeight, pixelSize, pixelWidth, renderFull, renderHUD, renderSymbol, renderUpdate, score, stepsLeft, stroke, textColor, touchKeyEvent, version, width, _i, _ref;
          version = '201402271910';
          console.log(version);
          Array.prototype.remove = function(arg) {
            return this.splice(this.indexOf(arg), 1);
          };
          canvas = document.getElementById('canvas');
          context = canvas.getContext('2d');
          width = window.innerWidth;
          height = window.innerHeight;
          pixelSize = [30, 20];
          pixelWidth = Math.floor(width / pixelSize[0]) - 1;
          pixelHeight = Math.floor(height / pixelSize[1]) - 1;
          boardSize = [31, 31];
          canvas.width = width;
          canvas.height = height;
          background = [0, 0, 0];
          stroke = ['rgb(0, 0, 0)', 'rgb(255, 255, 255)'];
          palette = [[191, 0, 0], [239, 127, 0], [255, 191, 0], [0, 191, 0], [0, 191, 191], [31, 0, 191], [191, 0, 255], [255, 0, 191], [0, 0, 0]];
          textColor = [95, 95, 95];
          hearts = [[[0, 0, 0], [1, 0, 1], [1, 1, 1], [0, 1, 0], [0, 0, 0]]];
          finSym = [[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[1, 1, 1], [1, 0, 0], [1, 1, 1], [1, 0, 0], [1, 0, 0]], [[1, 1, 1], [0, 1, 0], [0, 1, 0], [0, 1, 0], [1, 1, 1]], [[1, 1, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1]]];
          numbers = [[[1, 1, 1], [1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1]], [[1, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 0], [1, 1, 1]], [[1, 1, 1], [0, 0, 1], [1, 1, 1], [1, 0, 0], [1, 1, 1]], [[1, 1, 1], [0, 0, 1], [1, 1, 1], [0, 0, 1], [1, 1, 1]], [[1, 0, 1], [1, 0, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1]], [[1, 1, 1], [1, 0, 0], [1, 1, 1], [0, 0, 1], [1, 1, 1]], [[1, 1, 1], [1, 0, 0], [1, 1, 1], [1, 0, 1], [1, 1, 1]], [[1, 1, 1], [0, 0, 1], [0, 1, 1], [0, 0, 1], [0, 0, 1]], [[1, 1, 1], [1, 0, 1], [1, 1, 1], [1, 0, 1], [1, 1, 1]], [[1, 1, 1], [1, 0, 1], [1, 1, 1], [0, 0, 1], [0, 0, 1]]];
          context.fillStyle = "rgb(" + background[0] + ", " + background[1] + ", " + background[2] + ")";
          context.fillRect(0, 0, width, height);
          keys = {
            up: 'U',
            down: 'D',
            left: 'L',
            right: 'R'
          };
          loadPageVar = function(sVar) {
            return decodeURI(window.location.search.replace(new RegExp("^(?:.*[&\\?]" + encodeURI(sVar).replace(/[\.\+\*]/g, "\\$&") + "(?:\\=([^&]*))?)?.*$", "i"), "$1"));
          };
          if (loadPageVar('hi') === "false") {
            document.querySelectorAll('.mark, .intro').forEach(e => e.style.display = 'none')
            document.querySelectorAll('.blur').forEach(e => e.classList.remove('blur'))
          }
          level2 = parseInt(loadPageVar('level'));
          level = isNaN(level2) ? 5 : level2;
          gameOver = false;
          lives = 3;
          score = 0;
          stepsLeft = level;
          gen = function(size) {
            var actions, currentPixel, i, moveset, pixelSet, _i, _j, _k;
            moveset = "";
            actions = [];
            pixelSet = [];
            for (i = _i = 0; 0 <= pixelHeight ? _i < pixelHeight : _i > pixelHeight; i = 0 <= pixelHeight ? ++_i : --_i) {
              pixelSet.push([]);
              for (_j = 0; 0 <= pixelWidth ? _j < pixelWidth : _j > pixelWidth; 0 <= pixelWidth ? _j++ : _j--) {
                pixelSet[i].push(0);
              }
            }
            currentPixel = [Math.floor((pixelWidth - 1) * 0.5), Math.floor((pixelHeight - 1) * 0.5)];
            actions = [];
            pixelSet[currentPixel[1]][currentPixel[0]]++;
            for (i = _k = 0; 0 <= size ? _k < size : _k > size; i = 0 <= size ? ++_k : --_k) {
              actions = [keys.up, keys.down, keys.left, keys.right];
              if (currentPixel[1] < 2) {
                actions.remove(keys.up);
              } else if (currentPixel[1] > pixelHeight - 2) {
                actions.remove(keys.down);
              } else if (currentPixel[0] < 2) {
                actions.remove(keys.left);
              } else if (currentPixel[0] > pixelWidth - 2) {
                actions.remove(keys.right);
              }
              if (i > 0) {
                switch (moveset[i - 1]) {
                  case keys.up:
                    actions.remove(keys.down);
                    break;
                  case keys.down:
                    actions.remove(keys.up);
                    break;
                  case keys.left:
                    actions.remove(keys.right);
                    break;
                  case keys.right:
                    actions.remove(keys.left);
                }
              }
              moveset += actions[Math.floor(Math.random() * actions.length)];
              switch (moveset[i]) {
                case keys.up:
                  currentPixel[1]--;
                  break;
                case keys.down:
                  currentPixel[1]++;
                  break;
                case keys.left:
                  currentPixel[0]--;
                  break;
                case keys.right:
                  currentPixel[0]++;
              }
              pixelSet[currentPixel[1]][currentPixel[0]]++;
            }
            return pixelSet;
          };
          renderSymbol = function(symbolset, number, offsetX, offsetY) {
            var i, j, k, numString, _i, _j, _k, _ref, _ref1, _ref2;
            context.fillStyle = "rgb(" + textColor[0] + ", " + textColor[1] + ", " + textColor[2] + ")";
            numString = number.toString();
            for (i = _i = 0, _ref = numString.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              for (j = _j = 0, _ref1 = symbolset[parseInt(numString[i])].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
                for (k = _k = 0, _ref2 = symbolset[parseInt(numString[i])][j].length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                  if (symbolset[parseInt(numString[i])][j][k] === 1) {
                    context.fillRect((offsetX + i * (symbolset[parseInt(numString[i])][j].length + 1) + k) * pixelSize[0], (offsetY + j) * pixelSize[1], pixelSize[0], pixelSize[1]);
                    HUDArray[offsetY + j][offsetX + i * (symbolset[parseInt(numString[i])][j].length + 1) + k] = 1;
                  }
                }
              }
            }
            return 0;
          };
          HUDArray = [];
          renderHUD = function() {
            var i, j, _i, _j, _k;
            console.log("renderHUD");
            HUDArray = [];
            for (i = _i = 0; 0 <= pixelHeight ? _i < pixelHeight : _i > pixelHeight; i = 0 <= pixelHeight ? ++_i : --_i) {
              HUDArray.push([]);
              for (j = _j = 0; 0 <= pixelWidth ? _j < pixelWidth : _j > pixelWidth; j = 0 <= pixelWidth ? ++_j : --_j) {
                HUDArray[i].push(0);
              }
            }
            if (gameOver) {
              context.fillStyle = "rgb(" + background[0] + ", " + background[1] + ", " + background[2] + ")";
              context.fillRect((Math.ceil(pixelWidth * .5 - 1.5 * (finSym[0][0].length + 1)) - 0.5) * pixelSize[0], (Math.ceil((pixelHeight - finSym[0].length) * .5) - 0.5) * pixelSize[1], (finSym[0][0].length + 1) * 3 * pixelSize[0], (finSym[0].length + 1) * pixelSize[1]);
              renderSymbol(finSym, 123, Math.ceil(pixelWidth * .5 - 1.5 * (finSym[0][0].length + 1)), Math.ceil((pixelHeight - finSym[0].length) * .5));
            }
            renderSymbol(numbers, level, 1, 1);
            for (i = _k = 0; 0 <= lives ? _k < lives : _k > lives; i = 0 <= lives ? ++_k : --_k) {
              renderSymbol(hearts, 0, pixelWidth - (hearts[0][0].length + 1) * (i + 1) + 1, 1);
            }
            context.fillRect(pixelWidth * pixelSize[0], pixelHeight * pixelSize[1], pixelSize[0], pixelSize[1]);
            return 0;
          };
          renderFull = function(pixelSet) {
            var k, x, y, _i, _j;
            context.fillStyle = "rgb(" + background[0] + ", " + background[1] + ", " + background[2] + ")";
            context.fillRect(0, 0, width, height);
            renderHUD();
            for (y = _i = 0; 0 <= pixelHeight ? _i < pixelHeight : _i > pixelHeight; y = 0 <= pixelHeight ? ++_i : --_i) {
              for (x = _j = 0; 0 <= pixelWidth ? _j < pixelWidth : _j > pixelWidth; x = 0 <= pixelWidth ? ++_j : --_j) {
                k = pixelSet[y][x] - 1;
                if (k > -1) {
                  if (k > palette.length - 1) {
                    k = palette.length - 1;
                  }
                  context.fillStyle = "rgb(" + palette[k][0] + ", " + palette[k][1] + ", " + palette[k][2] + ")";
                  context.fillRect(x * pixelSize[0] + 1, y * pixelSize[1] + 1, pixelSize[0] - 2, pixelSize[1] - 2);
                }
              }
            }
            context.strokeStyle = stroke[0];
            context.strokeRect(currentPixel[0] * pixelSize[0] + 0.5, currentPixel[1] * pixelSize[1] + 0.5, pixelSize[0] - 1, pixelSize[1] - 1);
            context.strokeStyle = stroke[1];
            context.strokeRect(currentPixel[0] * pixelSize[0] + 1.5, currentPixel[1] * pixelSize[1] + 1.5, pixelSize[0] - 3, pixelSize[1] - 3);
            return 0;
          };
          renderUpdate = function(pixelSet) {
            var i, k, pixels, _i, _len;
            context.strokeStyle = "rgb(" + background[0] + ", " + background[1] + ", " + background[2] + ")";
            context.strokeRect(lastPixel[0] * pixelSize[0] + 0.5, lastPixel[1] * pixelSize[1] + 0.5, pixelSize[0] - 1, pixelSize[1] - 1);
            pixels = [lastPixel, currentPixel];
            for (_i = 0, _len = pixels.length; _i < _len; _i++) {
              i = pixels[_i];
              k = pixelSet[i[1]][i[0]] - 1;
              if (k > -1) {
                if (k > palette.length - 1) {
                  k = palette.length - 1;
                }
                context.fillStyle = "rgb(" + palette[k][0] + ", " + palette[k][1] + ", " + palette[k][2] + ")";
                context.fillRect(i[0] * pixelSize[0] + 1, i[1] * pixelSize[1] + 1, pixelSize[0] - 2, pixelSize[1] - 2);
              } else {
                context.fillStyle = "rgb(" + background[0] + ", " + background[0] + ", " + background[0] + ")";
                context.fillRect(i[0] * pixelSize[0] + 1, i[1] * pixelSize[1] + 1, pixelSize[0] - 2, pixelSize[1] - 2);
              }
            }
            context.strokeStyle = stroke[0];
            context.strokeRect(currentPixel[0] * pixelSize[0] + 0.5, currentPixel[1] * pixelSize[1] + 0.5, pixelSize[0] - 1, pixelSize[1] - 1);
            context.strokeStyle = stroke[1];
            context.strokeRect(currentPixel[0] * pixelSize[0] + 1.5, currentPixel[1] * pixelSize[1] + 1.5, pixelSize[0] - 3, pixelSize[1] - 3);
            if (currentPixel[1] < 7) {
              context.fillStyle = "rgb(" + textColor[0] + ", " + textColor[1] + ", " + textColor[2] + ")";
              if (pixelSet[lastPixel[1]][lastPixel[0]] === 0 && HUDArray[lastPixel[1]][lastPixel[0]] === 1) {
                context.fillRect(lastPixel[0] * pixelSize[0], lastPixel[1] * pixelSize[1], pixelSize[0], pixelSize[1]);
              }
              if (pixelSet[currentPixel[1]][currentPixel[0]] === 0 && HUDArray[currentPixel[1]][currentPixel[0]] === 1) {
                context.fillRect(currentPixel[0] * pixelSize[0], currentPixel[1] * pixelSize[1], pixelSize[0], pixelSize[1]);
              }
            }
            return 0;
          };
          gameBoard = gen(level, true);
          cacheBoard = [];
          for (i = _i = 0, _ref = gameBoard.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            cacheBoard.push(gameBoard[i].slice(0));
          }
          currentPixel = [Math.floor((pixelWidth - 1) * 0.5), Math.floor((pixelHeight - 1) * 0.5)];
          lastPixel = currentPixel.slice(0);
          renderFull(gameBoard);
          escapeKey = function() {
            var _j, _k, _ref1, _ref2;
            if (gameOver) {
              gameOver = false;
              lives = 3;
              level = isNaN(level2) ? 5 : level2;
              score = 0;
              stepsLeft = level;
              gameBoard = gen(level, true);
              cacheBoard = [];
              for (i = _j = 0, _ref1 = gameBoard.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                cacheBoard.push(gameBoard[i].slice(0));
              }
              currentPixel = [Math.floor((pixelWidth - 1) * 0.5), Math.floor((pixelHeight - 1) * 0.5)];
              lastPixel = currentPixel.slice(0);
              renderFull(gameBoard);
            } else if (lives > 0) {
              lives--;
              gameBoard = [];
              for (i = _k = 0, _ref2 = cacheBoard.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
                gameBoard.push(cacheBoard[i].slice(0));
              }
              currentPixel = [Math.floor((pixelWidth - 1) * 0.5), Math.floor((pixelHeight - 1) * 0.5)];
              lastPixel = currentPixel.slice(0);
              stepsLeft = level;
              renderFull(gameBoard);
            } else {
              gameOver = true;
              console.log("Game Over ", {
                level: level,
                score: score,
                stepsLeft: stepsLeft
              });
              renderHUD();
            }
            return 0;
          };
          actionEvent = function(key) {
            var currentPixel2, _j, _ref1;
            if (gameOver) {
              return -1;
            }
            switch (key) {
              case keys.up:
                currentPixel2 = [currentPixel[0], currentPixel[1] - 1];
                break;
              case keys.down:
                currentPixel2 = [currentPixel[0], currentPixel[1] + 1];
                break;
              case keys.left:
                currentPixel2 = [currentPixel[0] - 1, currentPixel[1]];
                break;
              case keys.right:
                currentPixel2 = [currentPixel[0] + 1, currentPixel[1]];
                break;
              default:
                console.log("Input blocked: unknown key");
                return -1;
            }
            if (currentPixel2[1] < 0 || currentPixel2[1] > gameBoard.length - 1 || currentPixel2[0] < 0 || currentPixel2[0] > gameBoard[0].length - 1 || gameBoard[currentPixel2[1]][currentPixel2[0]] < 1) {
              console.log("Input blocked: not valid tile " + currentPixel2);
              return -1;
            }
            gameBoard[currentPixel[1]][currentPixel[0]]--;
            lastPixel = currentPixel.slice(0);
            currentPixel = currentPixel2.slice(0);
            if (--stepsLeft > 0) {
              console.log(stepsLeft);
              renderUpdate(gameBoard);
            } else {
              score += level;
              gameBoard = gen(++level, true);
              cacheBoard = [];
              for (i = _j = 0, _ref1 = gameBoard.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                cacheBoard.push(gameBoard[i].slice(0));
              }
              currentPixel = [Math.floor((pixelWidth - 1) * 0.5), Math.floor((pixelHeight - 1) * 0.5)];
              lastPixel = currentPixel.slice(0);
              stepsLeft = level;
              renderFull(gameBoard);
            }
            return 0;
          };
          keyEvent = function(ee) {
            var e, kc, key;
            e = window.event ? window.event : ee;
            kc = e.keyCode;
            if (kc === 38) {
              key = keys.up;
            } else if (kc === 40) {
              key = keys.down;
            } else if (kc === 37) {
              key = keys.left;
            } else if (kc === 39) {
              key = keys.right;
            } else if (kc === 27 || kc === 32) {
              return escapeKey();
            } else {
              console.log("Input blocked: unknown key");
              return -1;
            }
            return actionEvent(key);
          };
          touchKeyEvent = function(e) {
            var key, x, y;
            e.preventDefault();
            document.querySelectorAll('.mark, .intro').forEach(e => e.style.display = 'none')
            document.querySelectorAll('.blur').forEach(e => e.classList.remove('blur'))
            x = e.touches ? e.touches[0].clientX : e.clientX;
            y = e.touches ? e.touches[0].clientY : e.clientY;
            if (x > width * 0.7 && y > height * 0.70) {
              return escapeKey();
            } else if (x > width * 0.35 && x < width * 0.65 && y < height * 0.30) {
              key = keys.up;
            } else if (x > width * 0.35 && x < width * 0.65 && y > height * 0.70) {
              key = keys.down;
            } else if (x < width * 0.30 && y > height * 0.35 && y < height * 0.65) {
              key = keys.left;
            } else if (x > width * 0.70 && y > height * 0.35 && y < height * 0.65) {
              key = keys.right;
            } else {
              console.log("Input blocked: unknown key");
              return -1;
            }
            return actionEvent(key);
          };
          document.addEventListener('keyup', keyEvent, false);
          document.addEventListener('click', touchKeyEvent, false);
          document.addEventListener('touchstart', touchKeyEvent, false);
          document.body.addEventListener('touchmove', function(e) {
            return e.preventDefault();
          });
        }).call(this);
      </script>
  </body>
</html>